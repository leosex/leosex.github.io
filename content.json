{"meta":{"title":null,"subtitle":null,"description":null,"author":"个人技术学习","url":"https://www.zhaoyantao.top","root":"/"},"pages":[{"title":"关于","date":"2022-09-16T03:00:49.879Z","updated":"2022-09-16T03:00:49.879Z","comments":false,"path":"about/index.html","permalink":"https://www.zhaoyantao.top/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-09-16T02:59:36.888Z","updated":"2022-09-16T02:59:36.888Z","comments":false,"path":"categories/index.html","permalink":"https://www.zhaoyantao.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-09-16T03:01:09.451Z","updated":"2022-09-16T03:01:09.451Z","comments":false,"path":"tags/index.html","permalink":"https://www.zhaoyantao.top/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-09-16T03:10:01.957Z","updated":"2022-09-16T02:24:31.020Z","comments":false,"path":"/404.html","permalink":"https://www.zhaoyantao.top/404.html","excerpt":"","text":""}],"posts":[{"title":"windows精品软件推荐","slug":"windows精品软件推荐","date":"2022-04-26T07:52:25.000Z","updated":"2022-09-16T07:30:26.598Z","comments":true,"path":"2022/04/26/windows精品软件推荐/","link":"","permalink":"https://www.zhaoyantao.top/2022/04/26/windows%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"","text":"软件推荐列表 专业清理垃圾工具：CleanMyPC 强大的本地文件搜索工具：Everything 万能编辑器：VsCode 专业卸载工具：Geek Uninstaller 好用轻量的截图软件： Snipaste 安全防御软件：火绒安全软件 ==================================================================","categories":[{"name":"软件工具","slug":"软件工具","permalink":"https://www.zhaoyantao.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://www.zhaoyantao.top/tags/windows/"}]},{"title":"js基础","slug":"Js基础","date":"2022-03-26T03:32:21.000Z","updated":"2022-09-16T07:33:36.474Z","comments":true,"path":"2022/03/26/Js基础/","link":"","permalink":"https://www.zhaoyantao.top/2022/03/26/Js%E5%9F%BA%E7%A1%80/","excerpt":"","text":"数据类型**值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。 引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。 一个变量声明，但未赋值，输出则是 undefined 函数没有明确返回值，如果用变量接受，输出则是 undefined Undefine + number = NaN 变量变量的声明 关键字 let， const，var 123let a = 100; // 作用域 从当前声明 到当前代码块结束（&#125;）可读可写const b = 100; // 作用域 从当前声明 到当前代码块结束（&#125;）只读var c = 100; // 作用域 全局作用域 var 会出现变量提升 在不声明变量之前c是undefined 解构赋值 12345678910111213// 数组的解构let [a, b, c] = [1, 2, 3];// a = 1// b = 2// c = 3let [a, , b] = [1, 2, 3];// a = 1// b = 3// 对象的解构let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;// foo = &#x27;aaa&#x27;// bar = &#x27;bbb&#x27; 变量的转换12345678910// 字符串转numberparseInt(&quot;1234blue&quot;); //returns 1234parseInt(&quot;0xA&quot;); //returns 10parseInt(&quot;22.5&quot;); //returns 22parseInt(&quot;blue&quot;); //returns NaN// number转字符串let n = 1234567890;var str1 = n + &quot;&quot;;var str2 = String(n);var str3 = n.toString(); 变量的类型判断typeof 可查看变量类型，一个变量应只存一个类型的数据。 12345678910111213141516171819// Numberconsole.log(typeof 37);console.log(typeof 3.14);// 字符串console.log(typeof &quot;bla&quot;);// 布尔值 booleanconsole.log(typeof true);// Symbols symbolsconsole.log(typeof Symbol(&quot;foo&quot;));// 对象 objectconsole.log( typeof &#123; a: 1, &#125;);object.isArray(); // 判断是否是数组// 函数console.log(typeof function () &#123;&#125;); 变量命名规范 变量的第一个字符必须是字母、下划线、或$ 其余的字符必须是 下划线 、字母、数字、或$ 不能用 js 的关键字 驼峰命名法 字符串（String）12345678let str = &quot;hello leo leo!&quot;;let len = str.length; // 获取字符串长度str.substring(start, end); // 截取字符串从start位置到end位置，如果end缺省则到结尾str.substr(start, length); // 截取字符串从start位置截取length个字符str.indexOf(&quot;a&quot;, start); // 返回字符串中检索&#x27;a&#x27;第一次出现的位置, 若无则返回-1；start:开始的位置str = str.replace(&quot;leo&quot;, &quot;world&quot;); // 字符串替换 字后str:&quot;hello world leo!&quot; 只能替换第一个子串str = str.replace(/leo/g, &quot;北京&quot;); // 字符串 正则表达式替换 字后str:&quot;hello world world!&quot; 数组1234567891011121314let arr = new Array();arr.push(2); // 向数组的末尾添加一个或更多元素，并返回新的长度。arr.pop(); // 删除数组的最后一个元素并返回删除的元素。arr = [1, 4, 5, 6, 7, 8];let retArr = arr.filler((item) =&gt; item &lt; 5); //使数组中通过筛选条件((item) =&gt; item &lt; 5)的的每个元素创建新数组。retArr.forEach((item, index) =&gt; &#123; console.log(item, index); // forEach 就是遍历数组 item就是每一元素 index 就是每个元素的数组下标&#125;);let retIndex = retArr.findIndex((item) =&gt; item === 1); // retIndex是返回满足条件的第一条元素对应的数组下标let retData = retArr.find((item) =&gt; item === 1); // retData 是返回满足条件的第一个元素retArr。retArr.reverse(); //数组的翻转// 最后数组的复杂排序 函数在开发中函数是什么函数是用来实现一定功能的代码块代码块就是包裹在花括号中所有代码 12345678910111213141516/** * functionName 就是函数名 * @param &#123;*&#125; parameters 函数的传参 */function functionName(parameters) &#123; //执行代码块的所有代码 console.log(parameters);&#125;/*js函数声明就是以下面结构封装的代码块关键字function 方法名(参数1， 参数2) &#123; 代码块&#125;*/ 函数声明后不会立即执行，当我们调用函数的时候才会执行, 下面做个示范 1234567891011121314151617// 函数定义同时在js中也是函数声明 定义了一个获取全名的函数 两个参数 一个是姓， 一个名 返回值是全名function getFullName(xing, ming) &#123; //执行代码块的所有代码 let fullName = xing + ming; return fullName; // 打印下名，但是下面的代码不会执行，因为上面执行了return console.log(ming);&#125;const xing = &quot;韩&quot;;const ming = &quot;强&quot;;const fullName = getFullName(xing, ming);console.log(fullName);// 函数能可以有返回值，也可以没有返回值， 当我们需要返回一个有效值，就可以通过return 返回有效值// return 在函数的代码块中是终止代码块的向下执行， 也就是return下面的代码将不会再执行// 比如说上面的打印名的代码 函数定义的三种方式 函数关键字(function)语句 123function fnMethodName(x) &#123; alert(x);&#125; 函数字面量(Function Literals) 123var fnMethodName = function (x) &#123; alert(x);&#125;; Function()构造函数 12var fnMethodName = new Function(‘x&#x27;,&#x27;alert(x);&#x27;)// 由Function构造函数的参数个数可变。最后一个参数写函数体，前面的参数写入参。 箭头函数箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式， 一种只包含一个表达式，省略掉了{ … }和 return。还有一种可以包含多条语句，这时候就不能省略{ … }和 return 12345678910111213// 第一种() =&gt; return &#x27;hello&#x27;(a, b) =&gt; a + b// 如果返回一个对象，需要特别注意，如果是单表达式要返回自定义对象，不写括号会报错，因为和函数体的&#123; ... &#125;有语法冲突。 如下() =&gt;&#123; return &#123;msg: &#x27;hello&#x27;&#125;&#125;// 第二种(a) =&gt; &#123; a = a + 1 return a&#125; 普通函数和箭头函数的区别对象内置对象Math，Date，String，Array，Object，Promise，Symbol，Map ， Set，Class 类 Promise 是一个对象，从它可以获取异步操作的消息 1234567891011121314151617181920212223242526const promise = new Promise(function (resolve, reject) &#123; // ... some code /* con 异步操作成功 */ if (con) &#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);// Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。promise.then( function (value) &#123; // success &#125;, function (error) &#123; // failure &#125;);// then 成功的回调 catch 失败的回调promise .then(function (value) &#123; // success &#125;) .catch(function (error) &#123; // failure &#125;); Symbol 表示独一无二的值，最大的用法是用来定义对象的唯一属性名。 自定义对象 Json 对象 1234567891011// json对象转json字符串let obj = &#123; id: 1, age: 22, name: &quot;leo&quot;,&#125;;let str = JSON.stringify(obj);let str = obj.toJSONString();// json字符串转 json对象let obj = str.parseJSON(); // 将JSON字符串转换为JSON对象let obj = JSON.parse(str); // 将字符串转换为JSON对象 创建自定义对象有几种方式 基于已有对象扩充其属性和方法 12345678let obj = new Object();obj.name = &quot;zhangsan&quot;;obj.sayName = function (name) &#123; this.name = name; alert(this.name);&#125;;obj.sayName(&quot;lisi&quot;);//这种方式的弊端：这种对象的可复用性不强，如果需要使用多个对象，还需要重新扩展其属性和方法。 工厂方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function createObject() &#123; var obj = new Object(); obj.username = &quot;zhangsan&quot;; obj.password = &quot;123&quot;; obj.get = function () &#123; alert(this.username + &quot;, &quot; + this.password); &#125;; return obj;&#125;var object1 = createObject();var object2 = createObject();object1.get();// 采用带参数的构造方法：function createObject(username, password) &#123; var obj = new Object(); obj.username = username; obj.password = password; obj.get = function () &#123; alert(this.username + &quot;, &quot; + this.password); &#125;; return obj;&#125;var object1 = createObject(&quot;zhangsan&quot;, &quot;123&quot;);object1.get();// 让多个对象共享函数对象 这样，不用每个对象都生成一个函数对象function get() &#123; alert(this.username + &quot;, &quot; + this.password);&#125;//函数对象只有一份function createObject(username, password) &#123; var object = new Object(); object.username = username; object.password = password; object.get = get; //每一个对象的函数对象都指向同一个函数对象 return object;&#125;var object1 = createObject(&quot;zhangsan&quot;, &quot;123&quot;);var object2 = createObject(&quot;lisi&quot;, &quot;456&quot;);object1.get();object2.get();//优点：让一个函数对象被多个对象所共享，而不是每一个对象拥有一个函数对象。//缺点：对象和它的方法定义分开了，可能会造成误解和误用。 构造函数方式 1234567891011121314151617// 构造函数的定义方法其实和普通的自定义函数相同。function Person() &#123; //在执行第一行代码前，js引擎会为我们生成一个对象 this.username = &quot;zhangsan&quot;; this.password = &quot;123&quot;; this.getInfo = function () &#123; alert(this.username + &quot;, &quot; + this.password); &#125;; //此处有一个隐藏的return语句，用于将之前生成的对象返回 //只有在后面用new的情况下，才会出现注释所述的这两点情况&#125;//生成对象let person = new Person(); //用了newperson.getInfo(); 原型(“prototype”)方式 12345678910111213141516171819function Person() &#123;&#125;Person.prototype.username = &quot;zhangsan&quot;;Person.prototype.password = &quot;123&quot;;Person.prototype.getInfo = function () &#123; alert(this.username + &quot;, &quot; + this.password);&#125;;var person = new Person();var person2 = new Person();person.username = &quot;lisi&quot;;person.getInfo();person2.getInfo();// 使用原型存在的缺点：1.不能传参数；2.有可能会导致程序错误。// 如果使用原型方式来定义对象，那么生成的所有对象会共享原型中的属性，这样一个对象改变了该属性也会反映到其他对象当中。// 单纯使用原型方式定义对象无法在构造函数中为属性赋初值，只能在对象生成后再去改变属性值。 动态原型方式 1234567891011121314151617181920212223// 在构造函数中通过标志量让所有对象共享一个方法，而每个对象拥有自己的属性。function Person() &#123; this.username = &quot;zhangsan&quot;; this.password = &quot;123&quot;; if (typeof Person.flag == &quot;undefined&quot;) &#123; //此块代码应该只在第一次调用的时候执行 alert(&quot;invoked&quot;); Person.prototype.getInfo = function () &#123; //这个方法定义在原型中，会被每一个对象所共同拥有 alert(this.username + &quot;, &quot; + this.password); &#125;; Person.flag = true; //第一次定义完之后，之后的对象就不需要再进来这块代码了 &#125;&#125;var p = new Person();var p2 = new Person();p.getInfo();p2.getInfo(); 浏览器对象所有浏览器都支持 window 对象。它代表浏览器的窗口。 所有全局 JavaScript 对象，函数和变量自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 1234567891011121314151617181920// 下面两种写法是一样的window.document.getElementById(&quot;blog&quot;);document.getElementById(&quot;blog&quot;);// 该例显示浏览器窗口的高度和宽度：（不包括工具栏和滚动条）var w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;var h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;// 下面的方法要了解一下window.open(); //打开新窗口window.close(); //关闭当前窗口window.moveTo(); //移动当前窗口window.resizeTo(); //重新调整当前窗口 运算相关(循环, 条件等)循环 for 循环 1234567891011121314let arr = [1, 2, 3, 8, 4];// for循环for (let i = 0; i &lt; arr.length; i++) &#123; console.log(i); // break 语句 可用于跳出循环。继续执行循环后的代码 // continue 语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代&#125;/** 语法 for (语句 1; 语句 2; 语句 3) &#123; 被执行的代码块 &#125; */ For/In 循环 12345let person = &#123; fname: &quot;Bill&quot;, lname: &quot;Gates&quot;, age: 56 &#125;;for (x in person) &#123; // x 为属性名 console.log(x);&#125; while 循环 1234567891011let i = 0;while (i &lt; 5) &#123; // 被执行的代码块 i++;&#125;/**while (条件)&#123; 需要执行的代码&#125;*/ do/while 循环 1234567891011do &#123; // 被执行的代码块 i++;&#125; while (i &lt; 5);/**do&#123; 需要执行的代码&#125;while (条件);*/ switch 语句 12345678910switch (n) &#123; case 1: //执行代码块 1 break; case 2: //执行代码块 2 break; //跳出switch语句 default: //与 case 1 和 case 2 不同时执行的代码&#125; 条件语句12345if (condition) &#123; //当条件为 true 时执行的代码&#125;// 变量的比较 a &gt; b a &lt; b a === b js 的 DOM 操作DOM 是什么DOM 的常用方法 获取节点： 1234document.getElementById(idName); //通过id号来获取元素，返回一个元素对象document.getElementsByName(name); //通过name属性获取id号，返回元素对象数组document.getElementsByClassName(className); //通过class来获取元素，返回元素对象数组（ie8以上才有）document.getElementsByTagName(tagName); //通过标签名获取元素，返回元素对象数组 获取/设置元素的属性值： 12element.getAttribute(attributeName); //括号传入属性名，返回对应属性的属性值element.setAttribute(attributeName, attributeValue); //传入属性名及设置的值 创建节点 Node： 123document.createElement(&quot;h3&quot;); //创建一个html元素，这里以创建h3元素为例document.createTextNode(String); //创建一个文本节点；document.createAttribute(&quot;class&quot;); //创建一个属性节点，这里以创建class属性为例 增添节点： 12elelment.appendChild(Node); //往element内部最后面添加一个节点，参数是节点类型elelment.insertBefore(newNode, existingNode); //在element内部的中在existingNode前面插入newNode 删除节点： 1element.removeChild(Node); //删除当前节点下指定的子节点，删除成功返回该被删除的节点，否则返回 null 1 DOM 的常用属性 获取当前元素的父节点 ： element.parentNode //返回当前元素的父节点对象 获取当前元素的子节点： element.chlidren //返回当前元素所有子元素节点对象，只返回 HTML 节点 element.chilidNodes //返回当前元素多有子节点，包括文本，HTML，属性节点。（回车也会当做一个节点） element.firstChild //返回当前元素的第一个子节点对象 element.lastChild //返回当前元素的最后一个子节点对象 获取当前元素的同级元素： element.nextSibling //返回当前元素的下一个同级元素 没有就返回 null element.previousSibling //返回当前元素上一个同级元素 没有就返回 null 获取当前元素的文本： element.innerHTML //返回元素的所有文本，包括 html 代码 element.innerText //返回当前元素的自身及子代所有文本值，只是文本内容，不包括 html 代码 获取当前节点的节点类型：node.nodeType //返回节点的类型,数字形式（1-12）常见几个 1：元素节点，2：属性节点，3：文本节点。 设置样式：element.style.color=“#eea”; //设置元素的样式时使用 style，这里以设置文字颜色为例。 ES6 模块export 与 import模块导入导出各种类型的变量，如字符串，数值，函数，类。 导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 不仅能导出声明还能导出引用（例如函数）。 export 命令可以出现在模块的任何位置，但必需处于模块顶层。 import 命令会提升到整个模块的头部，首先执行。 1234567891011121314151617/*-----export [test.js]-----*/let myName = &quot;Tom&quot;;let myAge = 20;let myfn = function () &#123; return &quot;My name is&quot; + myName + &quot;! I&#x27;m &#x27;&quot; + myAge + &quot;years old.&quot;;&#125;;let myClass = class myClass &#123; static a = &quot;yeah!&quot;;&#125;;export &#123; myName, myAge, myfn, myClass &#125;;/*-----import [xxx.js]-----*/import &#123; myName, myAge, myfn, myClass &#125; from &quot;./test.js&quot;;console.log(myfn()); // My name is Tom! I&#x27;m 20 years old.console.log(myAge); // 20console.log(myName); // Tomconsole.log(myClass.a); // yeah! as 的用法​ export 命令导出的接口名称，须和模块内部的变量有一一对应关系。导入的变量名，须和导出的接口名称相同，即顺序可以不一致。 12345678910111213141516171819/*-----export [test.js]-----*/let myName = &quot;Tom&quot;;export &#123; myName as exportName &#125;;/*-----import [xxx.js]-----*/import &#123; exportName &#125; from &quot;./test.js&quot;;console.log(exportName); // Tom//使用 as 重新定义导出的接口名称，隐藏模块内部的变量/*-----export [test1.js]-----*/let myName = &quot;Tom&quot;;export &#123; myName &#125;;/*-----export [test2.js]-----*/let myName = &quot;Jerry&quot;;export &#123; myName &#125;;/*-----import [xxx.js]-----*/import &#123; myName as name1 &#125; from &quot;./test1.js&quot;;import &#123; myName as name2 &#125; from &quot;./test2.js&quot;;console.log(name1); // Tomconsole.log(name2); // Jerry ES6 async1234async function name([param[, param[, ... param]]]) &#123; statements &#125;- name: 函数名称。- param: 要传递给函数的参数的名称。- statements: 函数体语句。 async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。 123456789async function helloAsync() &#123; return &quot;helloAsync&quot;;&#125;console.log(helloAsync()); // Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;helloAsync().then((v) =&gt; &#123; console.log(v); // helloAsync&#125;); await 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用。 1234[return_value] = await expression;//expression: 一个 Promise 对象或者任何要等待的值。//返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。// 如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。 1234567891011121314function testAwait(x) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(x); &#125;, 2000); &#125;);&#125;async function helloAsync() &#123; var x = await testAwait(&quot;hello world&quot;); console.log(x);&#125;helloAsync();// hello world JavaScript 原型和原型链https://zhuanlan.zhihu.com/p/250813781 https://www.cnblogs.com/tg666/p/12059205.html https://blog.csdn.net/lvanboy/article/details/88542746","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://www.zhaoyantao.top/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zhaoyantao.top/tags/JavaScript/"}]}],"categories":[{"name":"软件工具","slug":"软件工具","permalink":"https://www.zhaoyantao.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"},{"name":"前端开发","slug":"前端开发","permalink":"https://www.zhaoyantao.top/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://www.zhaoyantao.top/tags/windows/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zhaoyantao.top/tags/JavaScript/"}]}