{"meta":{"title":"一粒微沙","subtitle":"个人技术学习","description":"整理一些软件开发的文档","author":"个人技术学习","url":"https://www.zhaoyantao.top","root":"/"},"pages":[{"title":"关于","date":"2022-09-16T03:00:49.879Z","updated":"2022-09-16T03:00:49.879Z","comments":false,"path":"about/index.html","permalink":"https://www.zhaoyantao.top/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-09-16T02:59:36.888Z","updated":"2022-09-16T02:59:36.888Z","comments":false,"path":"categories/index.html","permalink":"https://www.zhaoyantao.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-09-16T03:01:09.451Z","updated":"2022-09-16T03:01:09.451Z","comments":false,"path":"tags/index.html","permalink":"https://www.zhaoyantao.top/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-09-16T03:10:01.957Z","updated":"2022-09-16T02:24:31.020Z","comments":false,"path":"/404.html","permalink":"https://www.zhaoyantao.top/404.html","excerpt":"","text":""}],"posts":[{"title":"windows精品软件推荐","slug":"windows精品软件推荐","date":"2022-04-26T07:52:25.000Z","updated":"2022-09-16T07:30:26.598Z","comments":true,"path":"2022/04/26/windows精品软件推荐/","link":"","permalink":"https://www.zhaoyantao.top/2022/04/26/windows%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"","text":"软件推荐列表 专业清理垃圾工具：CleanMyPC 强大的本地文件搜索工具：Everything 万能编辑器：VsCode 专业卸载工具：Geek Uninstaller 好用轻量的截图软件： Snipaste 安全防御软件：火绒安全软件 ==================================================================","categories":[{"name":"软件工具","slug":"软件工具","permalink":"https://www.zhaoyantao.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://www.zhaoyantao.top/tags/windows/"}]},{"title":"js基础","slug":"Js基础","date":"2022-03-26T03:32:21.000Z","updated":"2022-09-16T07:33:36.474Z","comments":true,"path":"2022/03/26/Js基础/","link":"","permalink":"https://www.zhaoyantao.top/2022/03/26/Js%E5%9F%BA%E7%A1%80/","excerpt":"","text":"数据类型**值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。 引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。 一个变量声明，但未赋值，输出则是 undefined 函数没有明确返回值，如果用变量接受，输出则是 undefined Undefine + number = NaN 变量变量的声明 关键字 let， const，var 123let a = 100; // 作用域 从当前声明 到当前代码块结束（&#125;）可读可写const b = 100; // 作用域 从当前声明 到当前代码块结束（&#125;）只读var c = 100; // 作用域 全局作用域 var 会出现变量提升 在不声明变量之前c是undefined 解构赋值 12345678910111213// 数组的解构let [a, b, c] = [1, 2, 3];// a = 1// b = 2// c = 3let [a, , b] = [1, 2, 3];// a = 1// b = 3// 对象的解构let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;// foo = &#x27;aaa&#x27;// bar = &#x27;bbb&#x27; 变量的转换12345678910// 字符串转numberparseInt(&quot;1234blue&quot;); //returns 1234parseInt(&quot;0xA&quot;); //returns 10parseInt(&quot;22.5&quot;); //returns 22parseInt(&quot;blue&quot;); //returns NaN// number转字符串let n = 1234567890;var str1 = n + &quot;&quot;;var str2 = String(n);var str3 = n.toString(); 变量的类型判断typeof 可查看变量类型，一个变量应只存一个类型的数据。 12345678910111213141516171819// Numberconsole.log(typeof 37);console.log(typeof 3.14);// 字符串console.log(typeof &quot;bla&quot;);// 布尔值 booleanconsole.log(typeof true);// Symbols symbolsconsole.log(typeof Symbol(&quot;foo&quot;));// 对象 objectconsole.log( typeof &#123; a: 1, &#125;);object.isArray(); // 判断是否是数组// 函数console.log(typeof function () &#123;&#125;); 变量命名规范 变量的第一个字符必须是字母、下划线、或$ 其余的字符必须是 下划线 、字母、数字、或$ 不能用 js 的关键字 驼峰命名法 字符串（String）12345678let str = &quot;hello leo leo!&quot;;let len = str.length; // 获取字符串长度str.substring(start, end); // 截取字符串从start位置到end位置，如果end缺省则到结尾str.substr(start, length); // 截取字符串从start位置截取length个字符str.indexOf(&quot;a&quot;, start); // 返回字符串中检索&#x27;a&#x27;第一次出现的位置, 若无则返回-1；start:开始的位置str = str.replace(&quot;leo&quot;, &quot;world&quot;); // 字符串替换 字后str:&quot;hello world leo!&quot; 只能替换第一个子串str = str.replace(/leo/g, &quot;北京&quot;); // 字符串 正则表达式替换 字后str:&quot;hello world world!&quot; 数组1234567891011121314let arr = new Array();arr.push(2); // 向数组的末尾添加一个或更多元素，并返回新的长度。arr.pop(); // 删除数组的最后一个元素并返回删除的元素。arr = [1, 4, 5, 6, 7, 8];let retArr = arr.filler((item) =&gt; item &lt; 5); //使数组中通过筛选条件((item) =&gt; item &lt; 5)的的每个元素创建新数组。retArr.forEach((item, index) =&gt; &#123; console.log(item, index); // forEach 就是遍历数组 item就是每一元素 index 就是每个元素的数组下标&#125;);let retIndex = retArr.findIndex((item) =&gt; item === 1); // retIndex是返回满足条件的第一条元素对应的数组下标let retData = retArr.find((item) =&gt; item === 1); // retData 是返回满足条件的第一个元素retArr。retArr.reverse(); //数组的翻转// 最后数组的复杂排序 函数在开发中函数是什么函数是用来实现一定功能的代码块代码块就是包裹在花括号中所有代码 12345678910111213141516/** * functionName 就是函数名 * @param &#123;*&#125; parameters 函数的传参 */function functionName(parameters) &#123; //执行代码块的所有代码 console.log(parameters);&#125;/*js函数声明就是以下面结构封装的代码块关键字function 方法名(参数1， 参数2) &#123; 代码块&#125;*/ 函数声明后不会立即执行，当我们调用函数的时候才会执行, 下面做个示范 1234567891011121314151617// 函数定义同时在js中也是函数声明 定义了一个获取全名的函数 两个参数 一个是姓， 一个名 返回值是全名function getFullName(xing, ming) &#123; //执行代码块的所有代码 let fullName = xing + ming; return fullName; // 打印下名，但是下面的代码不会执行，因为上面执行了return console.log(ming);&#125;const xing = &quot;韩&quot;;const ming = &quot;强&quot;;const fullName = getFullName(xing, ming);console.log(fullName);// 函数能可以有返回值，也可以没有返回值， 当我们需要返回一个有效值，就可以通过return 返回有效值// return 在函数的代码块中是终止代码块的向下执行， 也就是return下面的代码将不会再执行// 比如说上面的打印名的代码 函数定义的三种方式 函数关键字(function)语句 123function fnMethodName(x) &#123; alert(x);&#125; 函数字面量(Function Literals) 123var fnMethodName = function (x) &#123; alert(x);&#125;; Function()构造函数 12var fnMethodName = new Function(‘x&#x27;,&#x27;alert(x);&#x27;)// 由Function构造函数的参数个数可变。最后一个参数写函数体，前面的参数写入参。 箭头函数箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式， 一种只包含一个表达式，省略掉了{ … }和 return。还有一种可以包含多条语句，这时候就不能省略{ … }和 return 12345678910111213// 第一种() =&gt; return &#x27;hello&#x27;(a, b) =&gt; a + b// 如果返回一个对象，需要特别注意，如果是单表达式要返回自定义对象，不写括号会报错，因为和函数体的&#123; ... &#125;有语法冲突。 如下() =&gt;&#123; return &#123;msg: &#x27;hello&#x27;&#125;&#125;// 第二种(a) =&gt; &#123; a = a + 1 return a&#125; 普通函数和箭头函数的区别对象内置对象Math，Date，String，Array，Object，Promise，Symbol，Map ， Set，Class 类 Promise 是一个对象，从它可以获取异步操作的消息 1234567891011121314151617181920212223242526const promise = new Promise(function (resolve, reject) &#123; // ... some code /* con 异步操作成功 */ if (con) &#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);// Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。promise.then( function (value) &#123; // success &#125;, function (error) &#123; // failure &#125;);// then 成功的回调 catch 失败的回调promise .then(function (value) &#123; // success &#125;) .catch(function (error) &#123; // failure &#125;); Symbol 表示独一无二的值，最大的用法是用来定义对象的唯一属性名。 自定义对象 Json 对象 1234567891011// json对象转json字符串let obj = &#123; id: 1, age: 22, name: &quot;leo&quot;,&#125;;let str = JSON.stringify(obj);let str = obj.toJSONString();// json字符串转 json对象let obj = str.parseJSON(); // 将JSON字符串转换为JSON对象let obj = JSON.parse(str); // 将字符串转换为JSON对象 创建自定义对象有几种方式 基于已有对象扩充其属性和方法 12345678let obj = new Object();obj.name = &quot;zhangsan&quot;;obj.sayName = function (name) &#123; this.name = name; alert(this.name);&#125;;obj.sayName(&quot;lisi&quot;);//这种方式的弊端：这种对象的可复用性不强，如果需要使用多个对象，还需要重新扩展其属性和方法。 工厂方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function createObject() &#123; var obj = new Object(); obj.username = &quot;zhangsan&quot;; obj.password = &quot;123&quot;; obj.get = function () &#123; alert(this.username + &quot;, &quot; + this.password); &#125;; return obj;&#125;var object1 = createObject();var object2 = createObject();object1.get();// 采用带参数的构造方法：function createObject(username, password) &#123; var obj = new Object(); obj.username = username; obj.password = password; obj.get = function () &#123; alert(this.username + &quot;, &quot; + this.password); &#125;; return obj;&#125;var object1 = createObject(&quot;zhangsan&quot;, &quot;123&quot;);object1.get();// 让多个对象共享函数对象 这样，不用每个对象都生成一个函数对象function get() &#123; alert(this.username + &quot;, &quot; + this.password);&#125;//函数对象只有一份function createObject(username, password) &#123; var object = new Object(); object.username = username; object.password = password; object.get = get; //每一个对象的函数对象都指向同一个函数对象 return object;&#125;var object1 = createObject(&quot;zhangsan&quot;, &quot;123&quot;);var object2 = createObject(&quot;lisi&quot;, &quot;456&quot;);object1.get();object2.get();//优点：让一个函数对象被多个对象所共享，而不是每一个对象拥有一个函数对象。//缺点：对象和它的方法定义分开了，可能会造成误解和误用。 构造函数方式 1234567891011121314151617// 构造函数的定义方法其实和普通的自定义函数相同。function Person() &#123; //在执行第一行代码前，js引擎会为我们生成一个对象 this.username = &quot;zhangsan&quot;; this.password = &quot;123&quot;; this.getInfo = function () &#123; alert(this.username + &quot;, &quot; + this.password); &#125;; //此处有一个隐藏的return语句，用于将之前生成的对象返回 //只有在后面用new的情况下，才会出现注释所述的这两点情况&#125;//生成对象let person = new Person(); //用了newperson.getInfo(); 原型(“prototype”)方式 12345678910111213141516171819function Person() &#123;&#125;Person.prototype.username = &quot;zhangsan&quot;;Person.prototype.password = &quot;123&quot;;Person.prototype.getInfo = function () &#123; alert(this.username + &quot;, &quot; + this.password);&#125;;var person = new Person();var person2 = new Person();person.username = &quot;lisi&quot;;person.getInfo();person2.getInfo();// 使用原型存在的缺点：1.不能传参数；2.有可能会导致程序错误。// 如果使用原型方式来定义对象，那么生成的所有对象会共享原型中的属性，这样一个对象改变了该属性也会反映到其他对象当中。// 单纯使用原型方式定义对象无法在构造函数中为属性赋初值，只能在对象生成后再去改变属性值。 动态原型方式 1234567891011121314151617181920212223// 在构造函数中通过标志量让所有对象共享一个方法，而每个对象拥有自己的属性。function Person() &#123; this.username = &quot;zhangsan&quot;; this.password = &quot;123&quot;; if (typeof Person.flag == &quot;undefined&quot;) &#123; //此块代码应该只在第一次调用的时候执行 alert(&quot;invoked&quot;); Person.prototype.getInfo = function () &#123; //这个方法定义在原型中，会被每一个对象所共同拥有 alert(this.username + &quot;, &quot; + this.password); &#125;; Person.flag = true; //第一次定义完之后，之后的对象就不需要再进来这块代码了 &#125;&#125;var p = new Person();var p2 = new Person();p.getInfo();p2.getInfo(); 浏览器对象所有浏览器都支持 window 对象。它代表浏览器的窗口。 所有全局 JavaScript 对象，函数和变量自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 1234567891011121314151617181920// 下面两种写法是一样的window.document.getElementById(&quot;blog&quot;);document.getElementById(&quot;blog&quot;);// 该例显示浏览器窗口的高度和宽度：（不包括工具栏和滚动条）var w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;var h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;// 下面的方法要了解一下window.open(); //打开新窗口window.close(); //关闭当前窗口window.moveTo(); //移动当前窗口window.resizeTo(); //重新调整当前窗口 运算相关(循环, 条件等)循环 for 循环 1234567891011121314let arr = [1, 2, 3, 8, 4];// for循环for (let i = 0; i &lt; arr.length; i++) &#123; console.log(i); // break 语句 可用于跳出循环。继续执行循环后的代码 // continue 语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代&#125;/** 语法 for (语句 1; 语句 2; 语句 3) &#123; 被执行的代码块 &#125; */ For/In 循环 12345let person = &#123; fname: &quot;Bill&quot;, lname: &quot;Gates&quot;, age: 56 &#125;;for (x in person) &#123; // x 为属性名 console.log(x);&#125; while 循环 1234567891011let i = 0;while (i &lt; 5) &#123; // 被执行的代码块 i++;&#125;/**while (条件)&#123; 需要执行的代码&#125;*/ do/while 循环 1234567891011do &#123; // 被执行的代码块 i++;&#125; while (i &lt; 5);/**do&#123; 需要执行的代码&#125;while (条件);*/ switch 语句 12345678910switch (n) &#123; case 1: //执行代码块 1 break; case 2: //执行代码块 2 break; //跳出switch语句 default: //与 case 1 和 case 2 不同时执行的代码&#125; 条件语句12345if (condition) &#123; //当条件为 true 时执行的代码&#125;// 变量的比较 a &gt; b a &lt; b a === b js 的 DOM 操作DOM 是什么DOM 的常用方法 获取节点： 1234document.getElementById(idName); //通过id号来获取元素，返回一个元素对象document.getElementsByName(name); //通过name属性获取id号，返回元素对象数组document.getElementsByClassName(className); //通过class来获取元素，返回元素对象数组（ie8以上才有）document.getElementsByTagName(tagName); //通过标签名获取元素，返回元素对象数组 获取/设置元素的属性值： 12element.getAttribute(attributeName); //括号传入属性名，返回对应属性的属性值element.setAttribute(attributeName, attributeValue); //传入属性名及设置的值 创建节点 Node： 123document.createElement(&quot;h3&quot;); //创建一个html元素，这里以创建h3元素为例document.createTextNode(String); //创建一个文本节点；document.createAttribute(&quot;class&quot;); //创建一个属性节点，这里以创建class属性为例 增添节点： 12elelment.appendChild(Node); //往element内部最后面添加一个节点，参数是节点类型elelment.insertBefore(newNode, existingNode); //在element内部的中在existingNode前面插入newNode 删除节点： 1element.removeChild(Node); //删除当前节点下指定的子节点，删除成功返回该被删除的节点，否则返回 null 1 DOM 的常用属性 获取当前元素的父节点 ： element.parentNode //返回当前元素的父节点对象 获取当前元素的子节点： element.chlidren //返回当前元素所有子元素节点对象，只返回 HTML 节点 element.chilidNodes //返回当前元素多有子节点，包括文本，HTML，属性节点。（回车也会当做一个节点） element.firstChild //返回当前元素的第一个子节点对象 element.lastChild //返回当前元素的最后一个子节点对象 获取当前元素的同级元素： element.nextSibling //返回当前元素的下一个同级元素 没有就返回 null element.previousSibling //返回当前元素上一个同级元素 没有就返回 null 获取当前元素的文本： element.innerHTML //返回元素的所有文本，包括 html 代码 element.innerText //返回当前元素的自身及子代所有文本值，只是文本内容，不包括 html 代码 获取当前节点的节点类型：node.nodeType //返回节点的类型,数字形式（1-12）常见几个 1：元素节点，2：属性节点，3：文本节点。 设置样式：element.style.color=“#eea”; //设置元素的样式时使用 style，这里以设置文字颜色为例。 ES6 模块export 与 import模块导入导出各种类型的变量，如字符串，数值，函数，类。 导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 不仅能导出声明还能导出引用（例如函数）。 export 命令可以出现在模块的任何位置，但必需处于模块顶层。 import 命令会提升到整个模块的头部，首先执行。 1234567891011121314151617/*-----export [test.js]-----*/let myName = &quot;Tom&quot;;let myAge = 20;let myfn = function () &#123; return &quot;My name is&quot; + myName + &quot;! I&#x27;m &#x27;&quot; + myAge + &quot;years old.&quot;;&#125;;let myClass = class myClass &#123; static a = &quot;yeah!&quot;;&#125;;export &#123; myName, myAge, myfn, myClass &#125;;/*-----import [xxx.js]-----*/import &#123; myName, myAge, myfn, myClass &#125; from &quot;./test.js&quot;;console.log(myfn()); // My name is Tom! I&#x27;m 20 years old.console.log(myAge); // 20console.log(myName); // Tomconsole.log(myClass.a); // yeah! as 的用法​ export 命令导出的接口名称，须和模块内部的变量有一一对应关系。导入的变量名，须和导出的接口名称相同，即顺序可以不一致。 12345678910111213141516171819/*-----export [test.js]-----*/let myName = &quot;Tom&quot;;export &#123; myName as exportName &#125;;/*-----import [xxx.js]-----*/import &#123; exportName &#125; from &quot;./test.js&quot;;console.log(exportName); // Tom//使用 as 重新定义导出的接口名称，隐藏模块内部的变量/*-----export [test1.js]-----*/let myName = &quot;Tom&quot;;export &#123; myName &#125;;/*-----export [test2.js]-----*/let myName = &quot;Jerry&quot;;export &#123; myName &#125;;/*-----import [xxx.js]-----*/import &#123; myName as name1 &#125; from &quot;./test1.js&quot;;import &#123; myName as name2 &#125; from &quot;./test2.js&quot;;console.log(name1); // Tomconsole.log(name2); // Jerry ES6 async1234async function name([param[, param[, ... param]]]) &#123; statements &#125;- name: 函数名称。- param: 要传递给函数的参数的名称。- statements: 函数体语句。 async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。 123456789async function helloAsync() &#123; return &quot;helloAsync&quot;;&#125;console.log(helloAsync()); // Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;helloAsync().then((v) =&gt; &#123; console.log(v); // helloAsync&#125;); await 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用。 1234[return_value] = await expression;//expression: 一个 Promise 对象或者任何要等待的值。//返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。// 如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。 1234567891011121314function testAwait(x) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(x); &#125;, 2000); &#125;);&#125;async function helloAsync() &#123; var x = await testAwait(&quot;hello world&quot;); console.log(x);&#125;helloAsync();// hello world JavaScript 原型和原型链https://zhuanlan.zhihu.com/p/250813781 https://www.cnblogs.com/tg666/p/12059205.html https://blog.csdn.net/lvanboy/article/details/88542746","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://www.zhaoyantao.top/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zhaoyantao.top/tags/JavaScript/"}]},{"title":"一个C++邮件发送库jwsmtp","slug":"一个C++邮件发送库jwsmtp","date":"2019-08-28T04:52:25.000Z","updated":"2022-09-17T03:36:35.517Z","comments":true,"path":"2019/08/28/一个C++邮件发送库jwsmtp/","link":"","permalink":"https://www.zhaoyantao.top/2019/08/28/%E4%B8%80%E4%B8%AAC++%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%BA%93jwsmtp/","excerpt":"","text":"jwsmtp 编译安装 系统要求(全平台) 下载 编译安装 12345# 使用的 \b 版本 1.32.15 \b 好像好久没维护 \b 了，不过这个也没什么维护的。# mac 和 linux 如下编译 Windows 自行解决./configuremakesudo make install jwsmtp 发邮件 \bdemo(\b 同志们直接上代码，亲测有效)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &quot;jwsmtp/jwsmtp.h&quot;class MailToolObject&#123;public: MailToolObject(std::string sender_email, std::string sender_password, std::string sender_server)&#123; m_sender_email = sender_email; m_sender_password = sender_password; m_sender_server = sender_server; m_mailer = new jwsmtp::mailer(&quot;&quot;, m_sender_email.c_str(), &quot;&quot;, &quot;&quot;, sender_server.c_str(), jwsmtp::mailer::SMTP_PORT, false); &#125; ～MailToolObject()&#123; if(!m_mailer)&#123; delete m_mailer; m_mailer = NULL; &#125; &#125;public: bool sendMail(std::string sendTitle, std::string sendContent, std::vector&lt;std::string&gt; recvEmailUser)&#123; //添加多个接收者 for(int i=0;i&lt;recvEmailUser.size();i++) &#123; m_mailer-&gt;addrecipient(recvEmailUser[i]); &#125; // \b设置标题 m_mailer-&gt;setsubject(sendTitle); // 设置内容 m_mailer-&gt;setmessage(sendContent); //auth认证是PLAIN模式 m_mailer-&gt;authtype(jwsmtp::mailer::PLAIN); //用户名 m_mailer-&gt;username(m_sender_email); //密码 m_mailer-&gt;password(m_sender_password); m_mailer-&gt;send(); // 同步模式 std::string response = m_mailer-&gt;response(); // 获取返回验证码 int res = atoi(std::string(response.c_str(), 3).c_str()); if(res == 250)&#123; return true; &#125; std ::cout &lt;&lt; m_mailer-&gt;response() &lt;&lt; std::endl; return false; &#125;private: jwsmtp::mailer * m_mailer; std::string m_sender_email; std::string m_sender_password; std::string m_sender_server;&#125;;int main(int argc, char* argv[])&#123; MailToolObject mailToolObject(&quot;xxxxx@qq.com&quot;, &quot;xxxxxxx&quot;, &quot;smtp.qq.com&quot;); std::vector&lt;std::string&gt; recvEmailUser; recvEmailUser.push_back(&quot;xxxxxxx@qq.com&quot;); recvEmailUser.push_back(&quot;1111111@qq.com&quot;); bool res = mailToolObject.sendMail(&quot;标题&quot;, &quot;内容&quot;, recvEmailUser); if(res)&#123; printf(&quot;send email success!\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://www.zhaoyantao.top/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://www.zhaoyantao.top/tags/c/"}]},{"title":"c++代码覆盖率测试","slug":"c++代码覆盖率测试","date":"2019-07-22T04:52:25.000Z","updated":"2022-09-17T03:44:58.500Z","comments":true,"path":"2019/07/22/c++代码覆盖率测试/","link":"","permalink":"https://www.zhaoyantao.top/2019/07/22/c++%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%B5%8B%E8%AF%95/","excerpt":"","text":"技术栈阐述 系统（我采用的是 macos 线上使用 centos7） cmake 版本 3.2 以上，既然人家一直更新就用最新的稳定版 gcov 获取文本形式的覆盖率数据 lcov 获取 html 形式的覆盖率数据 cmake 来配置代码覆盖率测试 Cmakelist.txt1234567891011121314151617181920212223242526#基础环境安装yum -y install perl-Digest-MD5#lcov-1.14安装tar -xvf lcov-1.14.tarcd lcov-1.14sudo make install#设置cmake的编译类型 分为debug/release debug:我们来生成代码覆盖率测试报告#设置C++编译选项SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -std=c++11 -O0 -Wall -lpthread --coverage -ggdb&quot;)SET(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -std=c++11 -lpthread -O3 -Wall&quot;)#代码编译mkdir buildcd build &amp;&amp; cmake -DCMAKE_BUILD_TYPE=Debug ..makecd ..# 我的可执行文件在bin下 test 编译生成 .gcno 文件 运行生成 .gcda./bin/test# 运行后会在 build生成 .gcda文件 build是我的项目构建和编译目录# 运行完成我们开始生成html的代码覆盖率报告 我的源码在src下lcov --rc lcov_branch_coverage=1 -c -d build -o coverage.info_olcov --rc lcov_branch_coverage=1 -e coverage.info_o &quot;*src*&quot; -o coverage.infogenhtml --rc genhtml_branch_coverage=1 coverage.info -o coverage_reportrm -rf coverage.info_orm -rf coverage.info# 删除中间文件 coverage.info_o coverage.info 直接看 coverage_report 文件下的index.html 用谷歌浏览器打开 结束语最简单的 cmake 使用代码覆盖率测试已经加上，后期我加上谷歌的单元测试(gtest), 可以协助做代码覆盖率测试，我会把代码提交到 github，大家后期关注一下啊","categories":[{"name":"测试","slug":"测试","permalink":"https://www.zhaoyantao.top/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://www.zhaoyantao.top/tags/c/"}]},{"title":"Zookeeper安装和自定义服务注册","slug":"Zookeeper安装和自定义服务注册","date":"2019-07-15T04:23:25.000Z","updated":"2022-09-17T03:42:07.142Z","comments":true,"path":"2019/07/15/Zookeeper安装和自定义服务注册/","link":"","permalink":"https://www.zhaoyantao.top/2019/07/15/Zookeeper%E5%AE%89%E8%A3%85%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/","excerpt":"","text":"Zookeeper 安装 系统要求 开发环境我使用的 MacOS, linux 应该是绝对支持的，其他不晓得。 下载 配置及其运行 1234567891011121314151617# conf目录下提供了配置案例zoo_sample.cfg，要将zk运行起来，需要将其名称修改为zoo.cfg# tickTime 心跳时间# clientPort \b监听的端口号# dataDir=～./zookeeper/conf/dataDir 在conf下创建了dataDir保存 估计是些数据缓存，\b无所谓# \b自定义配置好九可以运行了 ./zkServer.sh start# \b出现错误了 错误: 找不到或无法加载主类 org.apache.zookeeper.server.quorum.QuorumPeerMain# 我用的3.5.5版本 最先的版本没有jar包，\b反手用上一个版本3.4.14 问题解决\b了./zkServer.sh status# ZooKeeper JMX enabled by default# Using config: /Users/leo/Leo/IM/zookeeper-3.4.14/bin/../conf/zoo.cfg# Mode: standalone 编译(重点来啦，这次就是想搞他) 123456# 进入c\b源码的\b目录 \b这个就是访问zk 的clientcd zookeeper-client/zookeeper-client-c./configuremakemake install# 默认安装到 头文件 /usr/local/include 库: /usr/local/lib 自定义服务注册 首先了解些 zkCli.sh 的一些命令操作 主要是创建永久节点 查询节点的相关情况 12345# 创建 create 节点 不加-s -e 则是永久节点 在跟节点创建永久节点servercreate / server# 查看 ls /server 节点 下面这个是查看根目录下的所有节点和server下节点ls /ls /server 代码创建临时节点，节点变化监听 在 server 下创建了临时节点 node1 属于服务组册 listenNode 属于节点监听 也就是服务监听 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;zookeeper/zookeeper.h&quot;void resultCB(int rc, const char *name, const void *data)&#123; fprintf(stderr, &quot;[%s]: rc = %d\\n&quot;, (char*)(data==0?&quot;null&quot;:data), rc); if (!rc) &#123; fprintf(stderr, &quot;\\tname = %s\\n&quot;, name); &#125;&#125;void listenNode(zhandle_t *zh,int type,int state,const char *path,void *watcherCtx)&#123; bool is_check = true; if(type == ZOO_SESSION_EVENT)&#123; if (state == ZOO_CONNECTED_STATE) &#123; printf(&quot;connected !\\n&quot;); &#125;else if (state == ZOO_CONNECTING_STATE)&#123; printf(&quot;connecting !\\n&quot;); is_check = false; &#125; &#125; if (is_check)&#123; struct String_vector paths; int ret = zoo_get_children(zh,&quot;/server&quot;,1,&amp;paths);// note: free mem if(ret) &#123; fprintf(stderr,&quot;Error %d for get_children\\n&quot;,ret); &#125; for(int i = 0;i &lt; paths.count;i++) printf(&quot;/server/%s\\n&quot;,paths.data[i]); &#125;&#125;int main(int argc,char *argv[])&#123; const char *host = &quot;127.0.0.1:2181&quot;; // 初始化 并且创建连接 和节点监听 zhandle_t * zh = zookeeper_init(host, listenNode, 30000, 0, 0, 0); if(zh == NULL) &#123; fprintf(stderr,&quot;Error when connecting to zookeeper servers...\\n&quot;); exit(EXIT_FAILURE); &#125; // 创建临时节点 相当于服务注册 int ret = zoo_acreate(zh, &quot;/server/node1&quot;, &quot;alive&quot;, 5, &amp;ZOO_OPEN_ACL_UNSAFE, ZOO_EPHEMERAL, resultCB, &quot;zoo_acreate&quot;); if (ret) &#123; fprintf(stderr, &quot;Error %d for %s\\n&quot;, ret, &quot;acreate&quot;); &#125; while(1)&#123;&#125; zookeeper_close(zh);&#125;","categories":[{"name":"中间件","slug":"中间件","permalink":"https://www.zhaoyantao.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://www.zhaoyantao.top/tags/Zookeeper/"}]},{"title":"hexo 使用说明","slug":"hexo使用说明","date":"2019-06-28T04:52:25.000Z","updated":"2022-09-17T03:30:08.163Z","comments":true,"path":"2019/06/28/hexo使用说明/","link":"","permalink":"https://www.zhaoyantao.top/2019/06/28/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"hexo 命令行使用常用命令123456789hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&#x27;Ctrl+C&#x27;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹** 简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 编辑文章新建文章1hexo new &quot;标题&quot; 在_posts 目录下会生成文件标题.md123456title: Hello Worlddate: 2015-07-30 07:56:29 #发表日期，一般不改动categories: hexo #文章文类tags: [hexo,github] #文章标签，多于一项时用这种格式---正文，使用Markdown语法书写 hexo 部署执行下列指令即可完成部署12hexo generatehexo deploy 以下提示说明部署成功1[info] Deploy done: git","categories":[{"name":"博客","slug":"博客","permalink":"https://www.zhaoyantao.top/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.zhaoyantao.top/tags/hexo/"}]}],"categories":[{"name":"软件工具","slug":"软件工具","permalink":"https://www.zhaoyantao.top/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"},{"name":"前端开发","slug":"前端开发","permalink":"https://www.zhaoyantao.top/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"c++","slug":"c","permalink":"https://www.zhaoyantao.top/categories/c/"},{"name":"测试","slug":"测试","permalink":"https://www.zhaoyantao.top/categories/%E6%B5%8B%E8%AF%95/"},{"name":"中间件","slug":"中间件","permalink":"https://www.zhaoyantao.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"博客","slug":"博客","permalink":"https://www.zhaoyantao.top/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://www.zhaoyantao.top/tags/windows/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zhaoyantao.top/tags/JavaScript/"},{"name":"c++","slug":"c","permalink":"https://www.zhaoyantao.top/tags/c/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://www.zhaoyantao.top/tags/Zookeeper/"},{"name":"hexo","slug":"hexo","permalink":"https://www.zhaoyantao.top/tags/hexo/"}]}